!pip install spektral

import spektral
import numpy as np
import scipy.sparse as sp
import tensorflow as tf
from spektral.data import Dataset, DisjointLoader, Graph
from tensorflow.keras.layers import Dense
from tensorflow.keras.losses import BinaryCrossentropy
from tensorflow.keras.metrics import binary_accuracy
from tensorflow.keras.metrics import binary_crossentropy
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam




class BinarySearchTreeNode:
    def __init__(self, data, weight, density, labels, serial_number):
        self.data = data
        self.weight = weight
        self.density = density
        self.labels = labels
        self.serial_number = serial_number
        self.left = None
        self.right = None



    def add_child(self, data, weight, density, labels, matrix, i):
        if data == self.data and weight == self.weight and density == self.density:
            return # node already exist

        if  density < self.density:
            if self.left:
                self.left.add_child(data,weight, density,labels, matrix, i)
            else:
                self.left = BinarySearchTreeNode(data,weight, density, labels, i)
                matrix[i][self.serial_number] = 1
                matrix[self.serial_number][i] = 1

        else:
            if self.right:
                self.right.add_child(data,weight, density, labels, matrix, i)
            else:
                self.right = BinarySearchTreeNode(data,weight, density, labels, i)
                matrix[i][self.serial_number] = 1
                matrix[self.serial_number][i] = 1



    def search(self, val,weight, dens):
        if self.data == val and self.weight == weight and self.density == dens:
            return True

        if dens < self.density:
            if self.left:
                return self.left.search(val,weight, dens)
            else:
                return False

        if dens > self.density:
            if self.right:
                return self.right.search(val,weight, dens)
            else:
                return False

    def in_order_traversal(self):
        elements = []
        if self.left:
            elements += self.left.in_order_traversal()

        elements.append([self.data, self.weight,self.density])

        if self.right:
            elements += self.right.in_order_traversal()

        return elements


def build_tree(elements, matrix):
    #print("Building tree with these elements:",elements)
    root = BinarySearchTreeNode(elements[0][0], elements[1][0], elements[2][0], elements[3][0], 0)

    for i in range(1,len(elements[0])):
        root.add_child(elements[0][i], elements[1][i], elements[2][i], elements[3][i], matrix, i)

    return root


class MyDataset(Dataset):

    def __init__(self, n_samples, item_count = 4000, **kwargs):
        self.n_samples = n_samples
        self.item_count = item_count
        super().__init__(**kwargs)


    def knapsack(self, weights, prices, maxCapacity):
      n = len(weights)
      dp = [[0 for j in range(maxCapacity+1)] for i in range(n+1)]
      for i in range(1, n+1):
        for j in range(1, maxCapacity+1):
          if weights[i-1] > j:
            dp[i][j] = dp[i-1][j]
          else:
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i-1]] + prices[i-1])
      selected = []
      i, j = n, maxCapacity
      while i > 0 and j > 0:
        if dp[i][j] != dp[i-1][j]:
          selected.append(i-1)
          j -= weights[i-1]
        i -= 1
      selected.reverse()
      y = [0 for i in range(len(weights))]
      for i in selected:
        y[i] = 1
      return y

    def create_knapsack(self):
      weights = np.random.randint(10, 80, self.item_count)
      prices = np.random.randint(1, 599, self.item_count)
      capacity =np.random.randint(62000, 63990)
      y = self.knapsack(weights, prices, capacity)
      return weights, prices, capacity, y


    def norm(self):
      weights, prices, capacity, y = self.create_knapsack()

      weights = weights / capacity
      prices = prices / max(prices)

      otnosh = [weights[i] / prices[i] for i in range (len(prices))]

      y = np.array(y, dtype = "float32")

      return weights, prices, y, otnosh


    def read(self):
        def make_graph():

            a = np.zeros((self.item_count,self.item_count))

            w, p, yy, otn = self.norm()

            numbers_tree = build_tree([p,w,otn, yy], a)

            # Node features
            x = np.zeros((3, self.item_count))
            x[0][:] = w
            x[1][:] = p
            x[2][:] = otn
            x = x.transpose()

            # Edges
            a = sp.csr_matrix(a)

            # Labels
            y = np.zeros((self.item_count, 1))
            for i in range(self.item_count):
              y[i][0] = yy[i]


            return Graph(x=x, a=a, y=y)

        # We must return a list of Graph objects
        return [make_graph() for _ in range(self.n_samples)]




data = MyDataset(1)

